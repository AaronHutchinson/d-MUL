/* 
   This is a Magma program which runs the d-MUL algorithm, as defined in the paper "Constructing Multidimensional Differential-Addition Chains and their Applications" by Aaron Hutchinson and Koray Karabina. 

   This code was written for the purpose of simplicity and ease of understanding and does not attempt to optimize the algorithm or make any additional security modifications outside of what is stated in the paper. Structure, notation, and indexing were matched with that of the paper as much as possible.

   The parameters of the algorithm and the elliptic curve setup are first set below. These can be modified as desired for testing on different curves or fields, and the dimension d can be changed to work with a different number of points. The three subalgorithms making up d-MUL are then defined, as in the paper. Finally, a sample testing environment is provided as a demonstration.

   This code was written on October 16, 2017 by Aaron Hutchinson and Koray Karabina.
*/

////////////////////////////////////
//      Parameters and Setup      //
///////////////////////////////////

d := 4;						// Dimension
Fp := GF(NextPrime(1000));			// Field of definition
E := EllipticCurve([Fp ! 1, Fp ! 1]);		// Elliptic curve choice
Generator := Points(E,1)[1];   	 		// In the testing demonstration, points in the 
	     					//   subgroup generated by Generator will be used
CurvePoints := [ Random([1..#Fp]) * Generator : i in [1..d] ];



////////////////////////////////////
//           Algorithm 1          //
////////////////////////////////////

// Algorithm 1 takes as input a sequence a and outputs a state matrix A having a as a row

Alg1 := function(a)

   // 1 //
   h := 0;
   for x in a do
      if x mod 2 eq 1 then
         h +:= 1;
      end if;
   end for;

   // 2 //
   A := ZeroMatrix(IntegerRing(), d+1, d);
   A[h+1] := Vector(a);

   // 4 //
   for i := h to 1 by -1 do
      A[i] := A[i+1];
      for j := 1 to d do
         if A[i][j] mod 2 eq 1 then       // Set to change matrix values from left to right
            A[i][j] -:= 1;                // Set to always subtract
            break;
         end if;
      end for;
   end for;

   // 5 //
   for i := h+2 to d+1 do
      A[i] := A[i-1];
      for j := 1 to d do
         if A[i][j] mod 2 eq 0 then       // Set to change matrix values from left to right
            A[i][j] -:= 1;                // Set to always subtract
            break;
         end if;
      end for;
   end for;

   return A;

end function;




////////////////////////////////////
//           Algorithm 2          //
////////////////////////////////////

// Algorithm 2 takes as input a state matrix A and returns a state matrix B
//   such that every row in A is the sum of two rows from B. The row index 
//   data connecting these sums between A and B are also returned in the table D.

Alg2 := function(A)

   // 1 //
   alpha := [ ExactQuotient(A[1][i],2) : i in [1..d] ];
   
   // 2 //
   // Compute the graph of sigma, then define sigma
   Graph := [ ];
   for i := 2 to d+1 do
      row := A[i] - A[i-1];
      for j := 1 to d do
         if row[j] ne 0 then
            Append( ~Graph, <i,j> );
            break;
         end if;
      end for;
   end for;
   sigma := map< {i : i in [2..d+1]} -> {i : i in [1..d]} | Graph>;
   
   // 3 //
   c := [ A[d+1][j] - A[1][j] : j in [1..d] ];

   // 4 //
   h := 0;
   for x in alpha do
      if x mod 2 eq 1 then
         h +:= 1;
      end if;
   end for;
   x := h+1;
   y := h+1;

   // 5 //
   B := ZeroMatrix(IntegerRing(), d+1, d);
   B[h+1] := Vector(alpha);
   R := Vector([ 0 : i in [1..d] ]);

   // 6 //
   D := [* [* 1, h+1, h+1, R *] *];	// A list is used here since we have different data types

   // 7 //
   for k := 2 to d+1 do
      
      // 8 //
      if alpha[ sigma(k) ] mod 2 eq 1 then
         e := Vector([ 0 : i in [1..d] ]);
	 e[sigma(k)] := c[sigma(k)];
	 B[x-1] := Vector(B[x]) + e;
         R := R + e;
         x -:= 1;
      end if;

      // 11 //
      if alpha[ sigma(k) ] mod 2 eq 0 then
         e := Vector([ 0 : i in [1..d] ]);
	 e[sigma(k)] := c[sigma(k)];
	 B[y+1] := Vector(B[y]) + e;
         R := R - e;
         y +:= 1;
      end if;

      // 15 //
      Append(~D, [* k, x, y, R *] );

   end for;

   return B,D;

end function;



////////////////////////////////////
//           Algorithm 3          //
////////////////////////////////////


// Magnitude function used in the while loop of Algorithm 3
Magnitude := function(A);
   return Max({ Abs(A[i][j]) : i in [1..NumberOfRows(A)] , j in [1..NumberOfColumns(A)] });
end function;


Alg3 := function(a,P)

   // Algorithm 3 takes as input a d-length integer sequence a and a d-length elliptic
   //  curve point sequence P. Algorithm 1 is called to construct a state matrix 
   //  containing A[1] a as a row. A sequence of state matrices A[k] are computed
   //  recursively using Algorithm 2. When the magnitude of the sequence reaches 1, the
   //  "dot product" a \cdot P is computed using the row relations between the matrices
   //  A[k] stored in the table D. The final output is the linear combination a \cdot P.

   A := [ ZeroMatrix(IntegerRing(), d+1,d) ];
   D := [* *];

   // 1 //
   A[1] := Alg1(a);

   // 2 //
   h := 0;
   for x in a do
      if x mod 2 eq 1 then
         h +:= 1;
      end if;
   end for;
   k := 1;

   // 3 //
   while Magnitude(A[k]) gt 1 do
      tempA,tempD := Alg2( A[k] );
      Append(~A, tempA);
      Append(~D, tempD);
      k +:= 1;
   end while;

   // 7 //
   Q := [ [] : i in [1..k] ];
   for i := 1 to d+1 do
      Q[k][i] := Identity(E);
      for j := 1 to d do
         Q[k][i] +:= A[k][i][j] * P[j];
      end for;
   end for;

   // 8 //
   k -:= 1;

   // 9 //
   while k gt 0 do
      for n := 1 to d+1 do
         Append( ~Q[k] , Q[k+1][ D[k][n][2] ] + Q[k+1][ D[k][n][3] ] );
      end for;
      k -:= 1;
   end while;

   return Q[1][h+1], A, D;

end function;


////////////////////////////////////
//          Demonstration         //
////////////////////////////////////


for k := 1 to 1000 do

   a := [ Random([1..#Fp]) : i in [1..d] ];
   Q := Alg3(a,CurvePoints);

   actual := Identity(E);
   for i := 1 to d do
      actual +:= a[i]*CurvePoints[i];
   end for;

   assert actual eq Q;

end for;
